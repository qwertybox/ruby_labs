class Person
  PFJFJ = 5
  def greet_by_name(name)
    if name == ""
      puts "Hello!"
    elsif
      puts "Hello, #{name}!"
    end
  end
end
class Friend < Person
  def greet_by_name(name)
    basic_greeting = super
    "#{basic_greeting} Glad to see you!"
  end
end
puts Friend.new.greet_by_name("Meghan")
puts Friend.new.greet_by_name("") # ruby не поддерживает перегрузку методов, таким образом в руби нельзя
#создать два метода с одинаковыми именами но разным колличеством соддержимого, таким образом нужно
# делать грабли и создавать конструкцию из if : http://rubylearning.com/satishtalim/ruby_overloading_methods.html
# https://coderoad.ru/1108612/%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-%D1%81-%D1%82%D0%B5%D0%BC-%D0%B6%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BC-%D0%B8-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B0%D0%BC%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0-%D0%B2-Ruby

# Любой класс Ruby может использоваться в качестве суперкласса.
# Чтобы определить субкласс,просто укажите суперкласс в определении класса.
# переменные экземпляра не наследуются от суперкласса — но наследуются
# методы, которые создают переменные экземпляра и обращаются к ним.
# Ключевое слово super может использоваться в методах
# субклассов для вызова одноименного переопределенного метода из суперкласса.
# Если ключевому слову super аргументы не передаются, то Ruby берет все
# аргументы, с которыми был вызван метод субклас- са, и передает их методу суперкласса.
# Значением выражения ключевого слова super является возвращаемое значение вызываемого метода суперкласса.
# Если при определении класса его супер- класс не задается явно, то Ruby неявно назначает им класс Object.
# Почти каждый объект Ruby содержит ме- тоды экземпляра из класса Object,
# унаследованные напрямую или через другой суперкласс.
# Методы to_s,methods,instance_ variables и class унаследованы от класса Object.
